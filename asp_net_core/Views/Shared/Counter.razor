@using System.Text.Json
@using System.Text.Json.Nodes

<div class="leftDiv">
    <div class="topbar">
        <h1>Desks</h1>
        <p>Refresh count: @currentCount</p>
        <button class="btn btn-primary blue" @onclick="CallBack"><img src="\refresh.svg" alt="Refresh"/></button>
    </div>
    <table>
        <thead>
            <tr>
                <th class="id">Id</th>
                <th>Name</th>
                <th class="status">Status</th>
                <th>Errors</th>
            </tr>
        </thead>
        <tbody>
            @foreach(var i in @deskData)
            {
                var id = i.Key;
                var value = i.Value;

                string? name = null;
                string? status = "disconnected";
                int? errorCount = null;

                if (value is not null)
                {
                    name = (value["config"]?["name"]??"").ToString();
                    status = (value["state"]?["status"]??"").ToString().ToLower();
                    errorCount = value["lastErrors"]?.AsArray().Count();
                }

                <tr class=@status>
                    <td>@id</td>
                    <td>@name</td>
                    <td class="status">@status</td>
                    <td>@errorCount</td>
                </tr>
            }
        </tbody>
    </table>
</div>
<div class="rightDiv">
    <p>Im a thing</p>
</div>

@code {
    private int currentCount = 0; // Refresh count
    private string[] deskIds = [];
    private Dictionary<string, JsonNode?> deskData = new();
    private HttpClient client = new();
    private CancellationTokenSource? _cts;

    private Task? _refreshTask;

    private System.Threading.Timer timer;

    private void StartAutoRefresh()
    {
        if (_cts != null) return; // already running

        _cts = new CancellationTokenSource();
        _refreshTask = Task.Run(() => RefreshLoopAsync(_cts.Token));
    }

    private void StopAutoRefresh()
    {
        _cts?.Cancel();
    }

    private async Task RefreshLoopAsync(CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                try
                {
                    await GetData();
                    // Ensure UI update from a background thread
                }
                catch (OperationCanceledException) { break; }
                catch
                {
                    // optionally log errors; swallow so the loop continues
                }

                await Task.Delay(100, token);
            }
        }
        finally
        {
            // clean up when loop ends
            _cts?.Dispose();
            _cts = null;
            _refreshTask = null;
        }
    }
    private void CallBack(object? state)
    {
        currentCount++;
        _ = InvokeAsync(GetData);
    }

    private async Task FetchDeskData()
    {
        timer = new System.Threading.Timer(
            CallBack, 
            null, 
            TimeSpan.Zero, 
            TimeSpan.FromSeconds(1));
    }

    private async Task GetData()
    {

        client.BaseAddress = new Uri("http://simulator:6000");
        var response = await client.GetAsync("/api/v2/F7H1vM3kQ5rW8zT9xG2pJ6nY4dL0aZ3K/desks");
        // deskIds = await response.Content.ReadAsStringAsync() ?? "No content";
        var content = await response.Content.ReadAsStreamAsync();
        deskIds = await JsonSerializer.DeserializeAsync<string[]>(content) ?? [];
        foreach (string desk in deskIds)
        {
            await GetDesk(desk);
        }
        await InvokeAsync(StateHasChanged);

        // client.Dispose();
    }

    private async Task GetDesk(string desk)
    {
        var response = await client.GetAsync($"/api/v2/F7H1vM3kQ5rW8zT9xG2pJ6nY4dL0aZ3K/desks/{desk}");
        var content = await response.Content.ReadAsStreamAsync();
        deskData[desk] = await JsonNode.ParseAsync(content);
    }
}